#include <WiFi.h>
#include <WebServer.h>
#include <FS.h>
#include <SPIFFS.h>
#include <time.h>
#include <DHT.h>

// WiFi and sensor configuration
const char* ssid = "Malik HSPT";
const char* password = "84e91ce5fe5a";
const int mq135Pin = 34;
#define DHTPIN 4
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 19800; // IST offset +5:30
const int daylightOffset_sec = 0;
const size_t MAX_CSV_SIZE = 50 * 1024; // 50 KB

WebServer server(80);

void initSPIFFS() {
  if (!SPIFFS.begin(true)) {
    Serial.println("Failed to mount SPIFFS");
  }
}

void appendDataToFile(const String& dataLine) {
  if (SPIFFS.exists("/data.csv")) {
    File f = SPIFFS.open("/data.csv", "r");
    if (f.size() > MAX_CSV_SIZE) {
      f.close();
      SPIFFS.remove("/data.csv");
      Serial.println("Old CSV deleted due to size limit");
    } else {
      f.close();
    }
  }
  File file = SPIFFS.open("/data.csv", FILE_APPEND);
  if (!file) {
    Serial.println("Failed to open file for appending");
    return;
  }
  if (file.print(dataLine)) {
    Serial.println("Data appended");
  } else {
    Serial.println("File write failed");
  }
  file.close();
}

void handleRoot() {
  String html = R"rawliteral(
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Garv Malik's ESP32 Clean Sensor Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
  body { font-family: 'Roboto', Arial, sans-serif; margin: 0; background: #f6f7fb; color: #23282c; }
  header { background: #fff; color: #23282c; padding: 2rem 2rem 1rem 2rem; font-size: 2rem; font-weight: 700;
           box-shadow: 0 3px 12px rgba(0,0,0,0.04); border-bottom: 1px solid #e3eaf1; letter-spacing: 0.01em;}
  main { padding: 1rem; max-width: 1100px; margin: auto; }
  .panel { background: #fff; border-radius: 14px; box-shadow: 0 2px 10px rgba(30,32,42,0.08); margin: 2rem 0; padding: 2rem 1.5rem 1.5rem 1.5rem;}
  h2 { font-size: 1.25rem; font-weight: 500; color: #1a1c1f; margin-top: 0; margin-bottom: 1.5rem; letter-spacing: 0.01em;}
  canvas { width: 100% !important; max-height: 350px !important; background: #fafbfc; border-radius: 8px; }
  .legend { font-size: 1rem; margin-top: .5rem; }
  .legend span { display: inline-block; margin-right: 1.5em; font-weight: 500; }
  .legend .blue { color: #3b82f6; }
  .legend .red   { color: #db4437; }
  .legend .green { color: #27ae60; }
  .download-btn {
    display: inline-block;
    margin: 1rem auto 2rem 0;  padding: 10px 26px; font-size: 1.1rem; background: #0860ca; color: white; font-weight: bold;
    border: none; border-radius: 5px; box-shadow:0 2px 7px rgba(32,90,187,0.10); text-decoration: none; cursor: pointer;
    transition: background 0.2s;
  }
  .download-btn:hover { background: #084887; }
  @media (max-width: 700px) {
    main, .panel { padding: 1rem 3vw; }
  }
</style>
</head>
<body>
<header>Garv Malik's ESP32 Clean Sensor Dashboard</header>
<main>
  <div class="panel">
    <h2>Performance Trends</h2>
    <canvas id="allTrendsChart"></canvas>
    <div class="legend">
      <span class="blue">&#11044; Air Quality</span>
      <span class="red">&#11044; Temperature (째C)</span>
      <span class="green">&#11044; Humidity (%)</span>
    </div>
    <a href="/download" class="download-btn" download="sensor_data.csv">Download CSV Data</a>
  </div>
  <div class="panel">
    <h2>Air Quality (MQ135)</h2>
    <canvas id="mq135Chart"></canvas>
  </div>
  <div class="panel">
    <h2>Temperature (째C)</h2>
    <canvas id="tempChart"></canvas>
  </div>
  <div class="panel">
    <h2>Humidity (%)</h2>
    <canvas id="humidityChart"></canvas>
  </div>
</main>
<script>
const allTrendsCtx = document.getElementById('allTrendsChart').getContext('2d');
const mq135Ctx     = document.getElementById('mq135Chart').getContext('2d');
const tempCtx      = document.getElementById('tempChart').getContext('2d');
const humidCtx     = document.getElementById('humidityChart').getContext('2d');

const allTrendsChart = new Chart(allTrendsCtx, {
  type: 'line',
  data: {
    labels: [],
    datasets: [
      {
        label: 'Air Quality',
        yAxisID: "y", // left axis
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59,130,246,0.125)',
        data: [],
        fill: false,
        tension: 0.38,
        borderWidth: 2,
        pointBackgroundColor: '#3b82f6',
        pointRadius: 4,
        pointHoverRadius: 6,
      },
      {
        label: 'Temperature (째C)',
        yAxisID: "y1", // right axis
        borderColor: '#db4437',
        backgroundColor: 'rgba(219,68,55,0.13)',
        data: [],
        fill: false,
        tension: 0.38,
        borderWidth: 2,
        pointBackgroundColor: '#db4437',
        pointRadius: 4,
        pointHoverRadius: 6,
      },
      {
        label: 'Humidity (%)',
        yAxisID: "y1", // right axis
        borderColor: '#27ae60',
        backgroundColor: 'rgba(39,174,96,0.13)',
        data: [],
        fill: false,
        tension: 0.38,
        borderWidth: 2,
        pointBackgroundColor: '#27ae60',
        pointRadius: 4,
        pointHoverRadius: 6,
      }
    ]
  },
  options: {
    responsive: true,
    plugins: {
      legend: { display: false },
      tooltip: { mode: 'index', intersect: false }
    },
    interaction: { mode: 'nearest', axis: 'x', intersect: false },
    scales: {
      x: {
        title: { display: true, text: "Date/Time", font: {weight:"bold"}, color: "#23282c" },
        ticks: { color: "#888", font: { size:13 }, maxTicksLimit:8 },
        grid: { color: "#ececec", borderColor: "#ececec" }
      },
      y: {
        position: 'left', title: {display:true, text:"AQ Sensor", padding:2, color:'#3b82f6', font:{weight:'bold'}},
        grid: { color: "#ececec", },
        ticks: { color: "#3b82f6", maxTicksLimit:7 }
      },
      y1: {
        position: 'right', title: {display:true, text:"Temp & Humidity", padding:2, color:'#db4437', font:{weight:'bold'}},
        grid: { drawOnChartArea: false },
        ticks: { color: "#db4437", maxTicksLimit:7 }
      }
    }
  }
});

function makeSingleLineChart(ctx, label, color) {
  return new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [{
      label: label,
      borderColor: color,
      backgroundColor: color,
      data: [],
      fill: false,
      tension: 0.4,
      borderWidth: 2,
      pointBackgroundColor: color,
      pointRadius: 4,
      pointHoverRadius: 6,
    }]},
    options: {
      responsive: true,
      plugins: {
        legend: { display: false },
        tooltip: { mode: 'index', intersect: false }
      },
      scales: {
        x: { grid: { color:"#ececec"}, ticks:{ maxTicksLimit:8, color:"#23282c", font:{size:13} } },
        y: { grid: { color:"#ececec"}, ticks:{ color: color, maxTicksLimit:6 } }
      }
    }
  });
}
const mq135Chart = makeSingleLineChart(mq135Ctx, "Air Quality", "#3b82f6");
const tempChart  = makeSingleLineChart(tempCtx, "Temperature (째C)", "#db4437");
const humidChart = makeSingleLineChart(humidCtx, "Humidity (%)", "#27ae60");

async function fetchSensorData() {
  try {
    const response = await fetch('/sensor');
    const text = await response.text();
    const parts = text.trim().split(",");
    if(parts.length !== 4) return;

    const label = parts[0];
    const mq135Val = parseFloat(parts[1]);
    const tempVal = parseFloat(parts[2]);
    const humidVal = parseFloat(parts[3]);
    let keep = 30;

    if (allTrendsChart.data.labels.length >= keep) {
      allTrendsChart.data.labels.shift();
      allTrendsChart.data.datasets.forEach(ds => ds.data.shift());
    }
    allTrendsChart.data.labels.push(label);
    allTrendsChart.data.datasets[0].data.push(mq135Val);
    allTrendsChart.data.datasets[1].data.push(tempVal);
    allTrendsChart.data.datasets[2].data.push(humidVal);
    allTrendsChart.update();

    [ [mq135Chart,mq135Val], [tempChart,tempVal], [humidChart,humidVal] ].forEach(([chart,dataval]) => {
      if (chart.data.labels.length >= keep) {
        chart.data.labels.shift(); chart.data.datasets[0].data.shift();
      }
      chart.data.labels.push(label); chart.data.datasets[0].data.push(dataval); chart.update();
    });
  } catch (error) {
    console.error('Error fetching sensor data:', error);
  }
}
setInterval(fetchSensorData, 1000);
</script>
</body>
</html>
)rawliteral";
  server.send(200, "text/html", html);
}

void handleSensor() {
  float temperature = dht.readTemperature();
  float humidity = dht.readHumidity();
  if (isnan(temperature) || isnan(humidity)) {
    temperature = 0;
    humidity = 0;
  }
  int mq135Value = analogRead(mq135Pin);
  struct tm timeinfo;
  char timestamp[24];
  if (!getLocalTime(&timeinfo)) {
    unsigned long totalSeconds = millis() / 1000;
    unsigned long minutes = totalSeconds / 60;
    unsigned long seconds = totalSeconds % 60;
    sprintf(timestamp, "%02lu:%02lu", minutes, seconds);
  } else {
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M", &timeinfo); // Date (hour:minute)
  }
  String dataLine = String(timestamp) + "," + String(mq135Value) + "," + String(temperature, 1) + "," + String(humidity, 0) + "\n";
  appendDataToFile(dataLine);
  server.send(200, "text/plain", String(timestamp) + "," + String(mq135Value) + "," + String(temperature, 1) + "," + String(humidity, 0));
}

void handleDownload() {
  File file = SPIFFS.open("/data.csv", "r");
  if (!file) {
    server.send(404, "text/plain", "File Not Found");
    return;
  }
  server.streamFile(file, "text/csv");
  file.close();
}

void setup() {
  Serial.begin(115200);
  initSPIFFS();
  dht.begin();

  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  Serial.print("Connected! IP Address: ");
  Serial.println(WiFi.localIP());

  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  Serial.println("Waiting for time sync...");
  struct tm timeinfo;
  while (!getLocalTime(&timeinfo)) {
    Serial.print(".");
    delay(500);
  }
  Serial.println("\nTime synced.");

  server.on("/", handleRoot);
  server.on("/sensor", handleSensor);
  server.on("/download", handleDownload);
  server.begin();
}

void loop() {
  server.handleClient();
}
