#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include <FS.h>
#include <SPIFFS.h>
#include <time.h>
#include <DHT.h>

// WiFi and sensor configuration
const char* ssid = "Malik HSPT";
const char* password = "84e91ce5fe5a";
const int mq135Pin = 34;
#define DHTPIN 4
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 19800;
const int daylightOffset_sec = 0;
const size_t MAX_CSV_SIZE = 50 * 1024;

WebServer server(80);

#define RL_VALUE 10
#define RO_CLEAN_AIR 3.6

void initSPIFFS() {
  if (!SPIFFS.begin(true)) {
    Serial.println("Failed to mount SPIFFS");
  }
}

float getPPM(int analogValue) {
  float ppm;
  
  if(analogValue < 500) {
    ppm = map(analogValue, 100, 500, 100, 300);
  } else if(analogValue < 1000) {
    ppm = map(analogValue, 500, 1000, 300, 600);
  } else if(analogValue < 1500) {
    ppm = map(analogValue, 1000, 1500, 600, 1000);
  } else if(analogValue < 2500) {
    ppm = map(analogValue, 1500, 2500, 1000, 2500);
  } else if(analogValue < 3500) {
    ppm = map(analogValue, 2500, 3500, 2500, 5000);
  } else {
    ppm = 5000 + (analogValue - 3500);
    if(ppm > 10000) ppm = 10000;
  }
  
  return ppm;
}

void appendDataToFile(const String& dataLine) {
  if (SPIFFS.exists("/data.csv")) {
    File f = SPIFFS.open("/data.csv", "r");
    if (f.size() > MAX_CSV_SIZE) {
      f.close();
      SPIFFS.remove("/data.csv");
      Serial.println("Old CSV deleted due to size limit");
    } else {
      f.close();
    }
  }
  File file = SPIFFS.open("/data.csv", FILE_APPEND);
  if (!file) {
    Serial.println("Failed to open file for appending");
    return;
  }
  if (file.print(dataLine)) {
    Serial.println("Data appended");
  } else {
    Serial.println("File write failed");
  }
  file.close();
}

void handleRoot() {
  String html = R"rawliteral(
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>A.T.M.O.S - Air Quality Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
  body { font-family: 'Roboto', Arial, sans-serif; margin: 0; background: #f6f7fb; color: #23282c; }
  header { background: #fff; color: #23282c; padding: 1.5rem 2rem; box-shadow: 0 3px 12px rgba(0,0,0,0.04); border-bottom: 1px solid #e3eaf1;}
  .header-container { display: flex; justify-content: space-between; align-items: center; max-width: 1100px; margin: auto; }
  .title-section { }
  .title { font-size: 2.5rem; font-weight: 700; letter-spacing: 0.02em; margin: 0; }
  .subtitle { font-size: 0.85rem; color: #666; margin-top: 0.3rem; font-weight: 400; font-style: italic; }
  .authors { font-size: 1rem; color: #333; font-weight: 700; text-align: right; }
  main { padding: 1rem; max-width: 1100px; margin: auto; }
  .panel { background: #fff; border-radius: 14px; box-shadow: 0 2px 10px rgba(30,32,42,0.08); margin: 2rem 0; padding: 2rem 1.5rem 1.5rem 1.5rem;}
  .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; flex-wrap: wrap; }
  h2 { font-size: 1.25rem; font-weight: 500; color: #1a1c1f; margin: 0; }
  .current-readings { display: flex; gap: 1.5rem; flex-wrap: wrap; }
  .reading-card { background: #f8f9fa; padding: 0.8rem 1.2rem; border-radius: 8px; border-left: 4px solid; }
  .reading-card.aqi { border-left-color: #9c27b0; min-width: 140px; }
  .reading-card.ppm { border-left-color: #3b82f6; }
  .reading-card.temp { border-left-color: #db4437; }
  .reading-card.humid { border-left-color: #27ae60; }
  .reading-label { font-size: 0.75rem; color: #666; text-transform: uppercase; letter-spacing: 0.05em; }
  .reading-value { font-size: 1.5rem; font-weight: 700; margin-top: 0.2rem; }
  .aqi-badge { display: inline-block; padding: 0.2rem 0.6rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; color: white; margin-top: 0.3rem; }
  canvas { width: 100% !important; max-height: 350px !important; background: #fafbfc; border-radius: 8px; }
  .legend { font-size: 1rem; margin-top: .5rem; }
  .legend span { display: inline-block; margin-right: 1.5em; font-weight: 500; }
  .legend .blue { color: #3b82f6; }
  .legend .red   { color: #db4437; }
  .legend .green { color: #27ae60; }
  .quality-indicators { display: flex; gap: 0.5rem; margin-top: 1rem; flex-wrap: wrap; font-size: 0.85rem; }
  .quality-item { padding: 0.5rem 1rem; border-radius: 6px; font-weight: 500; }
  .quality-good { background: #d4edda; color: #155724; }
  .quality-moderate { background: #ffa726; color: #000000; }
  .quality-poor { background: #f8d7da; color: #721c24; }
  .quality-unhealthy { background: #f5c6cb; color: #721c24; }
  .quality-verybad { background: #d6d8db; color: #383d41; }
  .aqi-note { font-size: 0.75rem; color: #666; margin-top: 0.5rem; font-style: italic; }
  .download-btn {
    display: inline-block;
    margin: 1rem auto 2rem 0;  padding: 10px 26px; font-size: 1.1rem; background: #0860ca; color: white; font-weight: bold;
    border: none; border-radius: 5px; box-shadow:0 2px 7px rgba(32,90,187,0.10); text-decoration: none; cursor: pointer;
    transition: background 0.2s;
  }
  .download-btn:hover { background: #084887; }
  @media (max-width: 768px) {
    .header-container { flex-direction: column; align-items: flex-start; }
    .authors { text-align: left; margin-top: 0.5rem; font-size: 0.9rem; }
    .title { font-size: 2rem; }
    main, .panel { padding: 1rem 3vw; }
    .header-row { flex-direction: column; align-items: flex-start; }
    .current-readings { width: 100%; margin-top: 1rem; }
  }
</style>
</head>
<body>
<header>
  <div class="header-container">
    <div class="title-section">
      <div class="title"><strong>A.T.M.O.S</strong></div>
      <div class="subtitle">Atmospheric Measurement and Observation System</div>
    </div>
    <div class="authors">
      <strong>by Garv Malik and Elisha Mishra<br>G.D.G.P.S (Karkardooma)</strong>
    </div>
  </div>
</header>
<main>
  <div class="panel">
    <div class="header-row">
      <h2>Performance Trends</h2>
      <div class="current-readings">
        <div class="reading-card aqi">
          <div class="reading-label">Estimated AQI</div>
          <div class="reading-value" id="currentAQI">--</div>
          <div class="aqi-badge" id="aqiBadge">Loading...</div>
        </div>
        <div class="reading-card ppm">
          <div class="reading-label">Air Quality</div>
          <div class="reading-value" id="currentPPM">-- PPM</div>
        </div>
        <div class="reading-card temp">
          <div class="reading-label">Temperature</div>
          <div class="reading-value" id="currentTemp">-- °C</div>
        </div>
        <div class="reading-card humid">
          <div class="reading-label">Humidity</div>
          <div class="reading-value" id="currentHumid">-- %</div>
        </div>
      </div>
    </div>
    <canvas id="allTrendsChart"></canvas>
    <div class="legend">
      <span class="blue">&#11044; Air Quality (PPM)</span>
      <span class="red">&#11044; Temperature (°C)</span>
      <span class="green">&#11044; Humidity (%)</span>
    </div>
    <div class="quality-indicators">
      <div class="quality-item quality-good">Good: &lt; 400 PPM (AQI 0-50)</div>
      <div class="quality-item quality-moderate">Moderate: 400-1000 PPM (AQI 51-100)</div>
      <div class="quality-item quality-poor">Poor: 1000-2000 PPM (AQI 101-150)</div>
      <div class="quality-item quality-unhealthy">Unhealthy: 2000-5000 PPM (AQI 151-200)</div>
      <div class="quality-item quality-verybad">Very Bad: &gt; 5000 PPM (AQI 201+)</div>
    </div>
    <div class="aqi-note">* AQI is estimated based on gas sensor readings and is not an official government AQI measurement</div>
    <a href="/download" class="download-btn" download="sensor_data.csv">Download CSV Data</a>
  </div>
  <div class="panel">
    <h2>Air Quality (PPM)</h2>
    <canvas id="mq135Chart"></canvas>
  </div>
  <div class="panel">
    <h2>Temperature (°C)</h2>
    <canvas id="tempChart"></canvas>
  </div>
  <div class="panel">
    <h2>Humidity (%)</h2>
    <canvas id="humidityChart"></canvas>
  </div>
</main>
<script>
const allTrendsCtx = document.getElementById('allTrendsChart').getContext('2d');
const mq135Ctx     = document.getElementById('mq135Chart').getContext('2d');
const tempCtx      = document.getElementById('tempChart').getContext('2d');
const humidCtx     = document.getElementById('humidityChart').getContext('2d');

function getAQIFromPPM(ppm) {
  if(ppm < 400) return Math.round((ppm / 400) * 50);
  else if(ppm < 1000) return Math.round(51 + ((ppm - 400) / 600) * 49);
  else if(ppm < 2000) return Math.round(101 + ((ppm - 1000) / 1000) * 49);
  else if(ppm < 5000) return Math.round(151 + ((ppm - 2000) / 3000) * 49);
  else if(ppm < 10000) return Math.round(201 + ((ppm - 5000) / 5000) * 99);
  else return 301;
}

function getAQICategory(aqi) {
  if(aqi <= 50) return 'Good';
  else if(aqi <= 100) return 'Moderate';
  else if(aqi <= 150) return 'Unhealthy for Sensitive';
  else if(aqi <= 200) return 'Unhealthy';
  else if(aqi <= 300) return 'Very Unhealthy';
  else return 'Hazardous';
}

function getAQIColor(aqi) {
  if(aqi <= 50) return '#00e400';
  else if(aqi <= 100) return '#ffb300';
  else if(aqi <= 150) return '#ff7e00';
  else if(aqi <= 200) return '#ff0000';
  else if(aqi <= 300) return '#8f3f97';
  else return '#7e0023';
}

const allTrendsChart = new Chart(allTrendsCtx, {
  type: 'line',
  data: {
    labels: [],
    datasets: [
      {
        label: 'Air Quality (PPM)',
        yAxisID: "y",
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59,130,246,0.125)',
        borderDash: [5,5],
        data: [],
        fill: false,
        tension: 0.38,
        borderWidth: 2,
        pointBackgroundColor: '#3b82f6',
        pointRadius: 4,
        pointHoverRadius: 6,
      },
      {
        label: 'Temperature (°C)',
        yAxisID: "y1",
        borderColor: '#db4437',
        backgroundColor: 'rgba(219,68,55,0.13)',
        data: [],
        fill: false,
        tension: 0.38,
        borderWidth: 2,
        pointBackgroundColor: '#db4437',
        pointRadius: 4,
        pointHoverRadius: 6,
      },
      {
        label: 'Humidity (%)',
        yAxisID: "y1",
        borderColor: '#27ae60',
        backgroundColor: 'rgba(39,174,96,0.13)',
        data: [],
        fill: false,
        tension: 0.38,
        borderWidth: 2,
        pointBackgroundColor: '#27ae60',
        pointRadius: 4,
        pointHoverRadius: 6,
      }
    ]
  },
  options: {
    responsive: true,
    animation: {
      progressive: true,
      easing: 'easeOutQuart'
    },
    plugins: {
      legend: { display: false },
      tooltip: { mode: 'index', intersect: false }
    },
    interaction: { mode: 'nearest', axis: 'x', intersect: false },
    scales: {
      x: {
        title: { display: true, text: "Date/Time", font: {weight:"bold"}, color: "#23282c" },
        ticks: { color: "#888", font: { size:13 }, maxTicksLimit:8 },
        grid: { color: "#ececec", borderColor: "#ececec" }
      },
      y: {
        position: 'left', title: {display:true, text:"Air Quality (PPM)", padding:2, color:'#3b82f6', font:{weight:'bold'}},
        grid: { color: "#ececec", },
        ticks: { color: "#3b82f6", maxTicksLimit:7 }
      },
      y1: {
        position: 'right', title: {display:true, text:"Temp & Humidity", padding:2, color:'#db4437', font:{weight:'bold'}},
        grid: { drawOnChartArea: false },
        ticks: { color: "#db4437", maxTicksLimit:7 }
      }
    }
  }
});

function makeSingleLineChart(ctx, label, color) {
  return new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [{
      label: label,
      borderColor: color,
      backgroundColor: color,
      data: [],
      fill: false,
      tension: 0.4,
      borderWidth: 2,
      pointBackgroundColor: color,
      pointRadius: 4,
      pointHoverRadius: 6,
    }]},
    options: {
      responsive: true,
      animation: {
        progressive: true,
        easing: 'easeOutQuart'
      },
      plugins: {
        legend: { display: false },
        tooltip: { mode: 'index', intersect: false }
      },
      scales: {
        x: { grid: { color:"#ececec"}, ticks:{ maxTicksLimit:8, color:"#23282c", font:{size:13} } },
        y: { grid: { color:"#ececec"}, ticks:{ color: color, maxTicksLimit:6 } }
      }
    }
  });
}
const mq135Chart = makeSingleLineChart(mq135Ctx, "Air Quality (PPM)", "#3b82f6");
const tempChart  = makeSingleLineChart(tempCtx, "Temperature (°C)", "#db4437");
const humidChart = makeSingleLineChart(humidCtx, "Humidity (%)", "#27ae60");

async function fetchSensorData() {
  try {
    const response = await fetch('/sensor');
    const text = await response.text();
    const parts = text.trim().split(",");
    if(parts.length !== 4) return;

    const label = parts[0];
    const mq135Val = parseFloat(parts[1]);
    const tempVal = parseFloat(parts[2]);
    const humidVal = parseFloat(parts[3]);
    
    const aqi = getAQIFromPPM(mq135Val);
    const aqiCategory = getAQICategory(aqi);
    const aqiColor = getAQIColor(aqi);
    
    document.getElementById('currentAQI').textContent = aqi;
    document.getElementById('currentPPM').textContent = mq135Val.toFixed(1) + ' PPM';
    document.getElementById('currentTemp').textContent = tempVal.toFixed(1) + ' °C';
    document.getElementById('currentHumid').textContent = humidVal.toFixed(0) + ' %';
    
    const badge = document.getElementById('aqiBadge');
    badge.textContent = aqiCategory;
    badge.style.backgroundColor = aqiColor;
    
    let keep = 30;

    if (allTrendsChart.data.labels.length >= keep) {
      allTrendsChart.data.labels.shift();
      allTrendsChart.data.datasets.forEach(ds => ds.data.shift());
    }
    allTrendsChart.data.labels.push(label);
    allTrendsChart.data.datasets[0].data.push(mq135Val);
    allTrendsChart.data.datasets[1].data.push(tempVal);
    allTrendsChart.data.datasets[2].data.push(humidVal);
    allTrendsChart.update();

    [ [mq135Chart,mq135Val], [tempChart,tempVal], [humidChart,humidVal] ].forEach(([chart,dataval]) => {
      if (chart.data.labels.length >= keep) {
        chart.data.labels.shift(); chart.data.datasets[0].data.shift();
      }
      chart.data.labels.push(label); chart.data.datasets[0].data.push(dataval); chart.update();
    });
  } catch (error) {
    console.error('Error fetching sensor data:', error);
  }
}
setInterval(fetchSensorData, 1000);
</script>
</body>
</html>
)rawliteral";
  server.send(200, "text/html", html);
}

void handleSensor() {
  float temperature = dht.readTemperature();
  float humidity = dht.readHumidity();
  if (isnan(temperature) || isnan(humidity)) {
    temperature = 0;
    humidity = 0;
  }
  
  int mq135AnalogValue = analogRead(mq135Pin);
  float mq135PPM = getPPM(mq135AnalogValue);
  
  Serial.print("Analog: ");
  Serial.print(mq135AnalogValue);
  Serial.print(" -> PPM: ");
  Serial.println(mq135PPM);
  
  struct tm timeinfo;
  char timestamp[24];
  if (!getLocalTime(&timeinfo)) {
    unsigned long totalSeconds = millis() / 1000;
    unsigned long minutes = totalSeconds / 60;
    unsigned long seconds = totalSeconds % 60;
    sprintf(timestamp, "%02lu:%02lu", minutes, seconds);
  } else {
    strftime(timestamp, sizeof(timestamp), "%y-%m-%d %H:%M:%S", &timeinfo);
  }
  
  String dataLine = String(timestamp) + "," + String(mq135PPM, 1) + "," + String(temperature, 1) + "," + String(humidity, 0) + "\n";
  appendDataToFile(dataLine);
  server.send(200, "text/plain", String(timestamp) + "," + String(mq135PPM, 1) + "," + String(temperature, 1) + "," + String(humidity, 0));
}

void handleDownload() {
  File file = SPIFFS.open("/data.csv", "r");
  if (!file) {
    server.send(404, "text/plain", "File Not Found");
    return;
  }
  server.streamFile(file, "text/csv");
  file.close();
}

void setup() {
  Serial.begin(115200);
  initSPIFFS();
  dht.begin();

  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  Serial.print("Connected! IP Address: ");
  Serial.println(WiFi.localIP());

  if (MDNS.begin("garv")) {
    Serial.println("mDNS started: http://garv.local");
  }

  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  Serial.println("Waiting for time sync...");
  struct tm timeinfo;
  int timeout = 0;
  while (!getLocalTime(&timeinfo) && timeout < 20) {
    Serial.print(".");
    delay(500);
    timeout++;
  }
  if (timeout >= 20) {
    Serial.println("\nTime sync failed");
  } else {
    Serial.println("\nTime synced.");
  }

  server.on("/", handleRoot);
  server.on("/sensor", handleSensor);
  server.on("/download", handleDownload);
  server.begin();
  
  MDNS.addService("http", "tcp", 80);
  
  Serial.println("Server started!");
  Serial.print("Access at: http://");
  Serial.print(WiFi.localIP());
  Serial.println(" or http://garv.local");
}

void loop() {
  server.handleClient();
}
