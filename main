#include <WiFi.h>
#include <WebServer.h>
#include <FS.h>
#include <SPIFFS.h>
#include <time.h>
#include <DHT.h>

const char* ssid = "Malik HSPT";
const char* password = "84e91ce5fe5a";

const int mq135Pin = 34;
const size_t MAX_CSV_SIZE = 50 * 1024; // 50 KB size limit

#define DHTPIN 4         
#define DHTTYPE DHT11    
DHT dht(DHTPIN, DHTTYPE);

const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 19800;    
const int   daylightOffset_sec = 0;

WebServer server(80);

void initSPIFFS() {
  if (!SPIFFS.begin(true)) {
    Serial.println("Failed to mount SPIFFS");
  }
}

void appendDataToFile(const String &dataLine) {
  if (SPIFFS.exists("/data.csv")) {
    File f = SPIFFS.open("/data.csv", "r");
    if (f.size() > MAX_CSV_SIZE) {
      f.close();
      SPIFFS.remove("/data.csv");
      Serial.println("Old CSV deleted due to size limit");
    } else {
      f.close();
    }
  }
  File file = SPIFFS.open("/data.csv", FILE_APPEND);
  if(!file) {
    Serial.println("Failed to open file for appending");
    return;
  }
  if(file.print(dataLine)) {
    Serial.println("Data appended");
  } else {
    Serial.println("File write failed");
  }
  file.close();
}

void handleRoot() {
  String html = R"rawliteral(
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP32 Sensor Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
<style>
  body { font-family: 'Roboto', sans-serif; margin: 0; background: #f5f7fa; color: #333; }
  header { background: #4285f4; color: white; padding: 1rem 2rem; font-size: 1.5rem; font-weight: 500; text-align: center; }
  .top-stats, .stats { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 1rem; max-width: 960px; margin: 1rem auto; }
  .stat-item {
    background: white;
    padding: 1rem 1.5rem;
    border-radius: 8px;
    box-shadow: 0 1px 6px rgba(0,0,0,0.1);
    text-align: center;
    flex: 1 1 120px;
    min-width: 120px;
  }
  .stat-item h2 {
    margin: 0;
    font-size: 1.75rem;
  }
  main { padding: 1rem 1rem 2rem 1rem; max-width: 960px; margin: auto; }
  canvas { background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); width: 100% !important; height: 300px !important; margin-bottom: 1.5rem; }
  a.download-btn {
    display: block;
    width: 100%;
    max-width: 200px;
    margin: 0 auto 2rem auto;
    padding: 10px;
    background: #4285f4;
    color: white;
    text-align: center;
    text-decoration: none;
    font-weight: bold;
    border-radius: 5px;
    box-shadow: 0 3px 6px rgba(66, 133, 244, 0.5);
    transition: background-color 0.3s ease;
  }
  a.download-btn:hover {
    background: #3367d6;
  }
</style>
</head>
<body>
<header>ESP32 Sensor Dashboard</header>

<!-- Current values displayed at top -->
<div class="top-stats">
  <div class="stat-item">
    <div>MQ135</div>
    <h2 id="currentMQ135Top">0</h2>
  </div>
  <div class="stat-item">
    <div>Temperature (째C)</div>
    <h2 id="currentTempTop">0</h2>
  </div>
  <div class="stat-item">
    <div>Humidity (%)</div>
    <h2 id="currentHumidTop">0</h2>
  </div>
</div>

<main>
  <h2>Combined Sensors</h2>
  <canvas id="combinedChart"></canvas>

  <h2>Individual Sensors</h2>
  <canvas id="mq135Chart"></canvas>
  <canvas id="tempChart"></canvas>
  <canvas id="humidityChart"></canvas>

  <!-- Current values also shown at bottom -->
  <div class="stats">
    <div class="stat-item">
      <div>MQ135</div>
      <h2 id="currentMQ135">0</h2>
    </div>
    <div class="stat-item">
      <div>Temperature (째C)</div>
      <h2 id="currentTemp">0</h2>
    </div>
    <div class="stat-item">
      <div>Humidity (%)</div>
      <h2 id="currentHumid">0</h2>
    </div>
  </div>

  <a href="/download" class="download-btn" download="sensor_data.csv">Download CSV Data</a>
</main>

<script>
function createChart(ctx, datasets) {
  return new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: datasets
    },
    options: {
      responsive: true,
      animation: { duration: 500, easing: 'easeOutQuart' },
      scales: {
        x: { title: { display: true, text: 'Time' }, ticks: { maxTicksLimit: 10 } },
        y: { beginAtZero: true }
      },
      plugins: { legend: { display: true }, tooltip: { mode: 'index' } }
    }
  });
}

const combinedCtx = document.getElementById('combinedChart').getContext('2d');
const mq135Ctx = document.getElementById('mq135Chart').getContext('2d');
const tempCtx = document.getElementById('tempChart').getContext('2d');
const humidityCtx = document.getElementById('humidityChart').getContext('2d');

const combinedDatasets = [
  { label: 'MQ135 Sensor Value', borderColor: '#4285f4', backgroundColor: 'rgba(66,133,244,0.3)', data: [], fill: true, tension: 0.4, pointRadius: 0 },
  { label: 'Temperature (째C)', borderColor: '#db4437', backgroundColor: 'rgba(219,68,55,0.3)', data: [], fill: true, tension: 0.4, pointRadius: 0 },
  { label: 'Humidity (%)', borderColor: '#f4b400', backgroundColor: 'rgba(244,180,0,0.3)', data: [], fill: true, tension: 0.4, pointRadius: 0 }
];

const combinedChart = createChart(combinedCtx, combinedDatasets);
const mq135Chart = createChart(mq135Ctx, [{
  label: 'MQ135 Sensor Value', borderColor: '#4285f4', backgroundColor: 'rgba(66,133,244,0.3)', data: [], fill: true, tension: 0.4, pointRadius: 0
}]);
const tempChart = createChart(tempCtx, [{
  label: 'Temperature (째C)', borderColor: '#db4437', backgroundColor: 'rgba(219,68,55,0.3)', data: [], fill: true, tension: 0.4, pointRadius: 0
}]);
const humidChart = createChart(humidityCtx, [{
  label: 'Humidity (%)', borderColor: '#f4b400', backgroundColor: 'rgba(244,180,0,0.3)', data: [], fill: true, tension: 0.4, pointRadius: 0
}]);

async function fetchSensorData() {
  try {
    const response = await fetch('/sensor');
    const text = await response.text();
    const parts = text.trim().split(",");
    if(parts.length !== 4) return;

    const label = parts[0];
    const mq135Val = parseFloat(parts[1]);
    const tempVal = parseFloat(parts[2]);
    const humidVal = parseFloat(parts[3]);

    function updateChart(chart, val) {
      if(chart.data.labels.length > 30){
        chart.data.labels.shift();
        chart.data.datasets[0].data.shift();
      }
      chart.data.labels.push(label);
      chart.data.datasets[0].data.push(val);
      chart.update();
    }

    if (combinedChart.data.labels.length > 30) {
      combinedChart.data.labels.shift();
    }
    combinedChart.data.labels.push(label);

    combinedChart.data.datasets[0].data.push(mq135Val);
    if (combinedChart.data.datasets[0].data.length > 30) combinedChart.data.datasets[0].data.shift();

    combinedChart.data.datasets[1].data.push(tempVal);
    if (combinedChart.data.datasets[1].data.length > 30) combinedChart.data.datasets[1].data.shift();

    combinedChart.data.datasets[2].data.push(humidVal);
    if (combinedChart.data.datasets[2].data.length > 30) combinedChart.data.datasets[2].data.shift();

    combinedChart.update();

    updateChart(mq135Chart, mq135Val);
    updateChart(tempChart, tempVal);
    updateChart(humidChart, humidVal);

    // Update values both top and bottom
    document.getElementById("currentMQ135").textContent = mq135Val.toFixed(0);
    document.getElementById("currentTemp").textContent = tempVal.toFixed(1);
    document.getElementById("currentHumid").textContent = humidVal.toFixed(0);

    document.getElementById("currentMQ135Top").textContent = mq135Val.toFixed(0);
    document.getElementById("currentTempTop").textContent = tempVal.toFixed(1);
    document.getElementById("currentHumidTop").textContent = humidVal.toFixed(0);

  } catch (error) {
    console.error('Error fetching sensor data:', error);
  }
}

setInterval(fetchSensorData, 1000);
</script>
</body>
</html>
)rawliteral";

  server.send(200, "text/html", html);
}

void handleSensor() {
  float temperature = dht.readTemperature();
  float humidity = dht.readHumidity();
  if (isnan(temperature) || isnan(humidity)) {
    Serial.println("Failed to read from DHT sensor!");
    temperature = 0;
    humidity = 0;
  }
  
  int mq135Value = analogRead(mq135Pin);

  struct tm timeinfo;
  char timestamp[20];
  if (!getLocalTime(&timeinfo)) {
    Serial.println("Failed to obtain NTP time");
    unsigned long totalSeconds = millis() / 1000;
    unsigned long minutes = totalSeconds / 60;
    unsigned long seconds = totalSeconds % 60;
    sprintf(timestamp, "%02lu:%02lu", minutes, seconds);
  } else {
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", &timeinfo);
  }

  String dataLine = String(timestamp) + "," + String(mq135Value) + "," + String(temperature, 1) + "," + String(humidity, 0) + "\n";
  appendDataToFile(dataLine);

  server.send(200, "text/plain", String(timestamp) + "," + String(mq135Value) + "," + String(temperature, 1) + "," + String(humidity, 0));
}

void handleDownload() {
  File file = SPIFFS.open("/data.csv", "r");
  if (!file) {
    server.send(404, "text/plain", "File Not Found");
    return;
  }
  server.streamFile(file, "text/csv");
  file.close();
}

void setup() {
  Serial.begin(115200);

  initSPIFFS();
  dht.begin();

  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  Serial.print("Connected! IP Address: ");
  Serial.println(WiFi.localIP());

  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  Serial.println("Waiting for time sync...");
  struct tm timeinfo;
  while (!getLocalTime(&timeinfo)) {
    Serial.print(".");
    delay(500);
  }
  Serial.println("\nTime synced.");

  server.on("/", handleRoot);
  server.on("/sensor", handleSensor);
  server.on("/download", handleDownload);

  server.begin();
}

void loop() {
  server.handleClient();
}
